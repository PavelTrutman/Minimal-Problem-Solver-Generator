\chapter{Polynomial system solving}
Firstly we review the state of the art algorithms for computing Gr\"obner basis. Better understanding of these algorithms helps us to integrate them more efficiently into polynomial solving algorithms based on Gr\"obner basis computation.

\section{Buchberger's Algorithm}
Buchberger's Algorithm \cite{Buchberger65}, which was invented by Bruno Buchberger, was the first algorithm for computing Gr\"obner basis. The algorithm is described in details in \cite{Becker93, Cox-Little-Shea97}.

\subsection{First implementation}
The first and easy, but very inefficient implementation of this algorithm is based on the observation that we can extend a set $F$ of polynomials to a Gr\"obner basis only by adding all non-zero remainders $\overline{S(f_i, f_j)}^F$ of all pairs from $F$ into $F$ until there is no non-zero remainder. The main disadvatage of this simple algorithm is that so constructed Gr\"obner basis are often bigger than necessary.

\begin{algorithm}[ht]
  \begin{algorithmic}[1]
    \Require
      \Statex $F$ a finite set of polynomials
    \Ensure
      \Statex $G$ a finite set of polynomials
      \Statex

    \State $G \gets F$
    \State $B \gets \left\{\left\{g_1, g_2\right\}\ |\ g_1, g_2 \in G,\ g_1 \neq g_2\right\}$
    \While{$B \neq \emptyset$}
      \State select $\left\{g_1, g_2\right\}$ from $B$
      \State $B \gets B\backslash\left\{\left\{g_1, g_2\right\}\right\}$
      \State $h \gets S(g_1, g_2)$
      \State $h_0 \gets \overline{h}^G$
      \If{$h_0 \neq 0$}
        \State $B \gets B \cup \left\{\left\{g, h_0\right\}\ |\ g\in G\right\}$
        \State $G \gets G \cup \left\{h_0\right\}$
      \EndIf
    \EndWhile

    \State \Return $G$

  \end{algorithmic}
  \caption{Simple Buchberger Algorithm}
\end{algorithm}

\subsection{Improved Buchberger Algorithm}
The combinatorial complexity of the simple implementation of the Buchberger Algorithm can be reduced by testing out certain S-polynomials which need not be considered. To know, which pairs can be deleted without treatment, we use the first and the second Buchberger's criteria \cite{Becker93}. Moreover, we can even delete certain polynomials from the set $G$, knowing that every critical pair that will occur in is superfluous and that these polynomials themselves will be superfluous in the output set. We call this mechanism, that achives these deletions of critical pairs and polynomials, as the function \textit{Update}.  In the next few paragpraphs we will describe the implementation of the Improved Buchberger Algorithm and of the function \textit{Update} due to Gebauer and M\"oller \cite{Gebauer-Moller88}.

The Improved Buchberger Algorithm has the same structure as the Simple Algorithm. The function \textit{Update} is used at the beginning of the Improved Buchberger Algorithm to initialize the set of critical pairs $B$ and the Gr\"obner basis $G$ from the input set $F$ of polynomials and at the point where a new non-zero polynomial $h_0 = \overline{h}^G$ of an S-polynomial $h$ has been found and the sets $B$ and $G$ are about to be updated.

\input{alg/ImprovedBuchberger.tex}

Now, let us look at the function \textit{Update} in details.

\input{alg/Update.tex}

\section{$F_4$ Algorithm}
The $F_4$ Algorithm \cite{F4} by Jean-Charles Faug\`ere is an improved version of the Buchberger's Algorithm. The $F_4$ replaces the classical polynomial reduction found in the Buchberger's Algorithm by a simultaneous reduction of several polynomials. This reduction mechanism is achieved by a symbolic precomputation followed by Gaussian elimination implemented using sparse linear algebra methods. $F_4$ speeds up the reduction step by exchanging multiple polynomial divisions for row-reduction of a single matrix.

\subsection{Improved Algorithm $F_4$}
The main function of $F_4$ Algorithm consists of two parts. The goal of the first part is to initialize the whole algorithm. First, it generates required pairs and initializes Gr\"obner basis $G$. Then it takes each polynomial from the input set and calls function \textit{Update} on it, which updates the set $P$ of pairs and the set $G$ of basic polynomials.

The second part of the algorithm generates new polynomials and includes them into the set $G$. In each iteration, it selects same pairs from $P$ using function \textit{Sel}. How to best select the pairs, is still an open question. Some selection strategies are described in the section \ref{subsec:F4:sel} on page \pageref{subsec:F4:sel}. Then, it splits each pair into two tuples. The first tuple contains the first polynomial $f_1$ of the pair and monomial $t_1$ such that $\textrm{LM}(t_1 \times f_1) = \textrm{lcm}(\textrm{LM}(f_1),\textrm{LM}(f_2))$. The second tuple is constructed in the same way from the second polynomial of the pair. All tuples from all selected pairs are put into the set $L$, i.e. duplicates are removed.

Next, it calls function \textit{Reduction} on the set $L$ and stores result in the set $\tilde{F}^+$. In the end it iterates throught all new polynomials in the set $\tilde{F}^+$ and calls function \textit{Update} on each of them. This generates new pairs into the set $P$ and extends Gr\"obner basis $G$.

This algorithm terminates when the set $P$ of pairs is empty. Then the set $G$ is a Gr\"obner basis and it is the output of the algorithm.

\begin{algorithm}[ht]
  \begin{algorithmic}[1]
    \Require
      \Statex $F$ a finite set of polynomials
      \Statex $Sel$ a function $List(Pairs) \to List(Pairs)$ such that $Sel(l) \neq \emptyset$ if $l\neq\emptyset$
    \Ensure
      \Statex $G$ a finite set of polynomials
      \Statex

    \State $G \gets \emptyset$
    \State $P \gets \emptyset$
    \State $d \gets 0$

    \While{$F \neq \emptyset$}
      \State $f \gets first(F)$
      \State $F \gets F\backslash \{f\}$
      \State $(G, P) \gets Update(G, P, f)$
    \EndWhile
    
    \While{$P\neq\emptyset$}
      \State $d \gets d + 1$
      \State $P_d \gets Sel(P)$
      \State $P \gets P\backslash P_d$
      \State $L_d \gets Left(P_d) \cup Right(P_d)$
      \State $(\tilde{F}^+_d, F_d) \gets Reduction(L_d, G, (F_i)_{i=1,\ldots,(d-1)})$
      \For{$h\in\tilde{F}^+_d$}
        \State $(G, P) \gets Update(G, P, h)$
      \EndFor
    \EndWhile
    \State \Return $G$

  \end{algorithmic}
  \caption{Improved Algorithm $F_4$}
\end{algorithm}

\subsection{Function Update}
In this algorithm is used standard implementation of Buchberger Criteria \textbf{CITE Gebauer and Moller [GM88]}.

\subsection{Function Reduction}
Task of this function is simple, it performs polynomial division using methods of linear algebra.

Input of this function is a set $L$ containing tuples of monomial and polynomial, which were made in the main function of the $F_4$ Algorithm.

First, this function calls function \textit{Symbolic Preprocessing} on the set $L$. This returns a set $F$ of polynomials to be reduced. To use linear algebra methods to perform polynomial division the polynomials have to be represented by a matrix. Each column of the matrix corresponds to a monomial and the columns have to be ordered with respect to the ordering used so that the most right column corresponds to ``1''. Each row of the matrix corresponds to a polynomial from the set $F$. Construction of the matrix is simple. On the $(i, j)$ posistion in the matrix, we put the coefficient of the term corresponding to $j$-th monomial from the $i$-th polynomial from the set $F$.

If we have constructed matrix like this we can reduce it to a row echelon form using, for example, Gauss-Jordan elimination. Note that this matrix is typically sparse so we can use sparse linear algebra methods to save computation time and memory. After elimination, we construct resulting polynomials by multiplying the reduced matrix by a vector of monomials from the \textbf{?????}.

In the end, the function returns the set of reduced polynomials that have leading monomials which were not amongs polynomials before reduction.

\begin{algorithm}[ht]
  \begin{algorithmic}[1]
    \Require
      \Statex $L$ a finite set of tuples of monomial and polynomial
      \Statex $G$ a finite set of polynomials
      \Statex $\mathcal{F} = (F_i)_{i=1,\ldots,(d-1)}$, where $F_i$ is finite set of polynomials
    \Ensure
      \Statex $\tilde{F}^+$ a finite set of polynomials
      \Statex $F$ a finite set of polynomials
      \Statex

    \State $F \gets Symbolic\ Preprocessing(L, G, \mathcal{F})$
    \State $\tilde{F} \gets$ Reduction to Row Echelon Form of $F$
    \State $\tilde{F^+} \gets \left\{f \in \tilde{F}\ |\ \textrm{LM}(f) \notin \textrm{LM}(F)\right\}$

    \State \Return $(\tilde{F}^+, F)$

  \end{algorithmic}
  \caption{Reduction}
\end{algorithm}

\subsection{Function Symbolic Preprocessing}
Function \textit{Symbolic Preprocessing} starts with a set $L$ of tuples containing monomial and polynomial. These tuples were made from selected pairs. Then, these tuples are simplified by function \textit{Simplify} and after multiplying polynomials with corresponding monomials the results are put into the set $F$.

Next, the function goes through all monomials in the set $F$ and for each monomial $m$ looks for some polynomial $f$ from Gr\"obner basis $G$ such $m = m^\prime \times \textrm{LM}(f)$ where $m^\prime$ is a some monomial. All such polynomials $f$ and monomials $m^\prime$ are after simplification multiplied and put into the set $F$. The goal of this search is to have for each monomial in $F$ some polynomial in $F$ with the same leading monomial. This will ensure that all added polynomials will be reduced for $G$ after polynomial division (using linear algebra).

\begin{algorithm}[ht]
  \begin{algorithmic}[1]
    \Require
      \Statex $L$ a finite set of tuples of monomial and polynomial
      \Statex $G$ a finite set of polynomials
      \Statex $\mathcal{F} = (F_i)_{i=1,\ldots,(d-1)}$, where $F_i$ is finite set of polynomials
    \Ensure
      \Statex $F$ a finite set of polynomials
      \Statex

    \State $F \gets \left\{multiply(Simplify(m, f, \mathcal{F}))\ |\ (m, f)\in L\right\}$
    \State $Done \gets \textrm{LM}(F)$
    \While{$\textrm{M}(F) \neq Done$}
      \State $m$ an element of $\textrm{M}(F)\backslash Done$
      \State $Done \gets Done \cup \{m\}$
      \If{$m$ is top reducible modulo $G$}
        \State $m = m^\prime \times \textrm{LM}(f)$ for some $f \in G$ and some monomial $m^\prime$
        \State $F \gets F \cup \left\{multiply(Simplify(m^\prime, f, \mathcal{F}))\right\}$
      \EndIf
    \EndWhile

    \State \Return $F$

  \end{algorithmic}
  \caption{Symbolic Preprocessing}
\end{algorithm}

\subsection{Function Simplify}
Function \textit{Simplify} simplifies a polynomial which is a product of the multiplication of a given monomial $m$ and a polynomial $f$.

The function recursively looks for a monomial $m^\prime$ and a polynomial $f^\prime$ such $\textrm{LM}(m^\prime\times f^\prime) = \textrm{LM}(m\times f)$. The polynomial $f^\prime$ is selected from all polynomials that has been reduced in previous iterations (sets $\tilde{F}^+$). We select polynomial $f^\prime$ such that total degree of $m^\prime$ is minimal.

This is done to insert into the set $F$ (set of polynomials ready to reduce) polynomials such that are mostly reduced and have small number of monomials. This of course speeds up following reduction.

\begin{algorithm}[ht]
  \begin{algorithmic}[1]
    \Require
      \Statex $m$ a monomial
      \Statex $f$ a polynomial
      \Statex $\mathcal{F} = (F_i)_{i=1,\ldots,(d-1)}$, where $F_i$ is finite set of polynomials
    \Ensure
      \Statex $(m^\prime, f^\prime)$ a non evaluated product of a monomial and a polynomial
      \Statex

    \For{$u \in$ list of all divisors of $m$}
      \If{$\exists j\ (1 \leq j \le d)$ such that $(u\times f) \in F_j$}
        \State $\tilde{F}_j$ is the Row Echelon Form of $F_j$
        \State there exists a (unique) $p\in \tilde{F}^+_j$ such that $\textrm{LM}(p) = \textrm{LM}(u\times f)$
        \If{$u\neq m$}
          \State \Return $Simplify(\frac{m}{u}, p, \mathcal{F})$
        \Else
          \State \Return $(1, p)$
        \EndIf
      \EndIf
    \EndFor

    \State \Return $(m, f)$

  \end{algorithmic}
  \caption{Simplify}
\end{algorithm}

\subsection{Selection strategy}
\label{subsec:F4:sel}
For the speed of the $F_4$ Algorithm is very important how to select in each iteration critical pairs from the list of all critical pairs $P$. This of course depends on the implemetation of the function \textit{Sel}. There are more possible implemetations:

\begin{itemize}
  \item The easiest implementation is to select all pairs from $P$. In this case we reduce all criticals pairs at the same time.
  \item If the function \textit{Sel} selects only one critical pair then the $F_4$ Algorithm is the Buchberger's Algorithm. In this case the \textit{Sel} function corresponds to the selection strategy in the Buchberger's Algorithm.
  \item The best function that Faug\`ere has tested is to select all critical pairs with a minimal total degree. Faug\`ere calls this strategy the \textit{normal strategy for} $F_4$.
\end{itemize}

\begin{algorithm}[ht]
  \begin{algorithmic}[1]
    \Require
      \Statex $P$ a list of critical pairs
    \Ensure
      \Statex $P_d$ a list of critical pairs
      \Statex

    \State $d \gets min\left\{\textrm{deg}(\textrm{lcm}(p))\ |\ p\in P\right\}$
    \State $P_d \gets \left\{p\in P\ |\ \textrm{deg}(\textrm{lcm}(p)) = d\right\}$
    \State \Return $P_d$
  \end{algorithmic}
  \caption{Sel -- The normal strategy for $F_4$}
\end{algorithm}

\section{$F_5$ Algorithm}
