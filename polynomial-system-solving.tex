\chapter{Polynomial system solving}
Firstly we review the state of the art algorithms for computing Gr\"obner basis. Better understanding of these algorithms helps us to integrate them more efficiently into polynomial solving algorithms based on Gr\"obner basis computation.

\section{Buchberger's Algorithm}
Buchberger's Algorithm \cite{Buchberger65}, which was invented by Bruno Buchberger, was the first algorithm for computing Gr\"obner basis. The algorithm is described in details in \cite{Becker93, Cox-Little-Shea97}.

\subsection{First implementation}
The first and easy, but very inefficient implementation of this algorithm is based on the observation that we can extend a set $F$ of polynomials to a Gr\"obner basis only by adding all non-zero remainders $\overline{S(f_i, f_j)}^F$ of all pairs from $F$ into $F$ until there is no non-zero remainder. The main disadvatage of this simple algorithm is that so constructed Gr\"obner basis are often bigger than necessary.

\input{alg/Buchberger.tex}

\subsection{Improved Buchberger's Algorithm}
\label{subsec:ImprovedBuchberger}
The combinatorial complexity of the simple implementation of the Buchberger's Algorithm can be reduced by testing out certain S-polynomials which need not be considered. To know, which pairs can be deleted without treatment, we use the first and the second Buchberger's criteria \cite{Becker93}. Moreover, we can even delete certain polynomials from the set $G$, knowing that every critical pair that will occur in is superfluous and that these polynomials themselves will be superfluous in the output set. We call this mechanism, that achives these deletions of critical pairs and polynomials, as the function \textit{Update}.  In the next few paragpraphs we will describe the implementation of the Improved Buchberger's Algorithm and of the function \textit{Update} according to Gebauer and M\"oller \cite{Gebauer-Moller88}.

The Improved Buchberger's Algorithm has the same structure as the Simple Algorithm. The function \textit{Update} is used at the beginning of the Improved Buchberger's Algorithm to initialize the set of critical pairs $B$ and the Gr\"obner basis $G$ from the input set $F$ of polynomials and at the point where a new non-zero polynomial $h_0 = \overline{h}^G$ of an S-polynomial $h$ has been found and the sets $B$ and $G$ are about to be updated.

\input{alg/ImprovedBuchberger.tex}

Now, let us look at the function \textit{Update} in more details. First, it makes pairs of the new polynomial $h$ and all polynomials from the set $G_{old}$ and all such pairs puts into the set $C$. The first while loop on lines \ref{alg:update:w1b} -- \ref{alg:update:w1e} puts from the set $C$ into the set $D$ all pairs $\{h, g_1\}$ such that $(h, g_2, g_1)$ is not a Buchberger triple, where $\{h, g_2\}$ is an another pair from the set $C$ or the set $D$. From the second Buchberger's criterion we know that if a Buchberger triple $(h, g_2, g_1)$ shows up in a Buchberger's Algorithm and the pairs $\{g_1, g_2\}$ and $\{h, g_2\}$ have been taken care of, then the pair $\{h, g_1\}$ need not to be treated. That means in our code that such a pair is not moved from the set $C$ to the set $D$, but it is only removed from the set $C$. This while loop keeps all pairs $\{h, g_1\}$ where LM$(h)$ and LM$(g_1)$ are disjoint. The reason of this is that if two or more pairs in $C$ have the same lcm of their leading monomials, then there is a choice which one should be deleted. So we keep the one where the leading monomials are disjoint. Pairs with disjoint leading monomials are removed in the second while loop, so we eventually remove them all.

As mentioned before the second while loop (lines \ref{alg:update:w2b} -- \ref{alg:update:w2e}) eliminates all pairs such their leading monomials are disjoint. All remaining pairs are stored in the set $E$. We can remove such pairs because of the first Buchberger's criterion.

The third while loop on lines \ref{alg:update:w3b} -- \ref{alg:update:w3e} eliminates from the set $B_{old}$ of old pairs those pairs $\{g_1, g_2\}$ where $(g_1, h, g_2)$ is a Buchberger triple. Then the updated set of the old pairs and the new pairs are united into the set $B_{new}$, which is the output of the function.

Finally, the last while loop in the function \textit{Update} removes from the set $G_{old}$ all polynomials $g$ whose leading monomial is a multiple of the leading monomial of $h$. We can eliminate such polynomials for two reasons. Firstly, LM$(h) \mid$ LM$(g)$ implies LM$(h) \mid$ lcm(LM$(g)$, LM$(f)$) for arbitrary polynomial $f$. We can see that $(g, h, f)$ is a Buchberger triple for any $f$ which in future appears in the set $G$. Moreover, polynomial $g$ will not be missed at the end, because in the Gr\"obner basis $G$, polynomials with leading monomial which is multiple of leading monomial of another polynomial from $G$ are superfluous.

In the end of the function the polynomial $h$ is added into the Gr\"obner basis $G_{new}$. The output of the function is the Gr\"obner basis $G_{new}$ and the set of critical pairs $B_{new}$.

\input{alg/Update.tex}

\section{$F_4$ Algorithm}
The $F_4$ Algorithm \cite{F4} by Jean-Charles Faug\`ere is an improved version of the Buchberger's Algorithm. The $F_4$ replaces the classical polynomial reduction found in the Buchberger's Algorithm by a simultaneous reduction of several polynomials. This reduction mechanism is achieved by a symbolic precomputation followed by Gaussian elimination implemented using sparse linear algebra methods. $F_4$ speeds up the reduction step by exchanging multiple polynomial divisions for row-reduction of a single matrix.

\subsection{Improved Algorithm $F_4$}
The main function of $F_4$ Algorithm consists of two parts. The goal of the first part is to initialize the whole algorithm. First, it generates required pairs and initializes the Gr\"obner basis $G$. Then it takes each polynomial from the input set and calls the function \textit{Update} on it, which updates the set $P$ of pairs and the set $G$ of basic polynomials.

The second part of the algorithm generates new polynomials and includes them into the set $G$. In each iteration, it selects same pairs from $P$ using the function \textit{Sel}. How to best select the pairs, is still an open question. Some selection strategies are described in the section \ref{subsec:F4:sel} on page \pageref{subsec:F4:sel}. Then, it splits each pair into two tuples. The first tuple contains the first polynomial $f_1$ of the pair and the monomial $m_1$ such that $\textrm{LM}(m_1 \times f_1) = \textrm{lcm}(\textrm{LM}(f_1),\textrm{LM}(f_2))$. The second tuple is constructed in the same way from the second polynomial of the pair. All tuples from all selected pairs are put into the set $L$, i.e. duplicates are removed.

Next, it calls the function \textit{Reduction} on the set $L$ and stores result in the set $\tilde{F}^+$. In the end it iterates throught all new polynomials in the set $\tilde{F}^+$ and calls the function \textit{Update} on each of them. This generates new pairs into the set $P$ and extends the Gr\"obner basis $G$.

This algorithm terminates when the set $P$ of pairs is empty. Then the set $G$ is a Gr\"obner basis and it is the output of the algorithm.

\input{alg/F4.tex}

\subsection{Function Update}
In this algorithm is used standard implementation of the Buchberger's Criteria such as the Gebauer and M\"oller installation \cite{Gebauer-Moller88}. Details about this function you can find in the section \ref{subsec:ImprovedBuchberger} and the pseudocode of this function as the algorithm \ref{alg:update}.

\subsection{Function Reduction}
Task of this function is simple, it performs polynomial division using methods of linear algebra.

Input of this function is a set $L$ containing tuples of monomial and polynomial, which were made in the main function of the $F_4$ Algorithm.

First, this function calls the function \textit{Symbolic Preprocessing} on the set $L$. This returns a set $F$ of polynomials to be reduced. To use linear algebra methods to perform polynomial division the polynomials have to be represented by a matrix. Each column of the matrix corresponds to a monomial and the columns have to be ordered with respect to the ordering used so that the most right column corresponds to ``1''. Each row of the matrix corresponds to a polynomial from the set $F$. Construction of the matrix is simple. On the $(i, j)$ posistion in the matrix, we put the coefficient of the term corresponding to $j$-th monomial from the $i$-th polynomial from the set $F$.

If we have constructed matrix like this we can reduce it to a row echelon form using, for example, Gauss-Jordan elimination. Note that this matrix is typically sparse so we can use sparse linear algebra methods to save computation time and memory. After elimination, we construct resulting polynomials by multiplying the reduced matrix by a vector of monomials from the \textbf{?????}.

In the end, the function returns the set of reduced polynomials that have leading monomials which were not amongs polynomials before reduction.

\input{alg/Reduction.tex}

\subsection{Function Symbolic Preprocessing}
Function \textit{Symbolic Preprocessing} starts with a set $L$ of tuples each containing monomial and polynomial. These tuples were made from the selected pairs. Then, these tuples are simplified by the function \textit{Simplify} and after multiplying polynomials with corresponding monomials the results are put into the set $F$.

Next, the function goes through all monomials in the set $F$ and for each monomial $m$ looks for some polynomial $f$ from the Gr\"obner basis $G$ such $m = m^\prime \times \textrm{LM}(f)$ where $m^\prime$ is some monomial. All such polynomials $f$ and monomials $m^\prime$ are after simplification multiplied and put into the set $F$. The goal of this search is to have for each monomial in $F$ some polynomial in $F$ with the same leading monomial. This will ensure that all added polynomials will be reduced for $G$ after polynomial division (using linear algebra).

\input{alg/SymbolicPreprocessing.tex}

\subsection{Function Simplify}
The function \textit{Simplify} simplifies a polynomial which is a product of the multiplication of a given monomial $m$ and a polynomial $f$.

The function recursively looks for a monomial $m^\prime$ and a polynomial $f^\prime$ such that $\textrm{LM}(m^\prime\times f^\prime) = \textrm{LM}(m\times f)$. The polynomial $f^\prime$ is selected from all polynomials that has been reduced in previous iterations (sets $\tilde{F}^+$). We select polynomial $f^\prime$ such that total degree of $m^\prime$ is minimal.

This is done to insert into the set $F$ (set of polynomials ready to reduce) polynomials such that are mostly reduced and have small number of monomials. This of course speeds up following reduction.

\input{alg/Simplify.tex}

\subsection{Selection strategy}
\label{subsec:F4:sel}
For the speed of the $F_4$ Algorithm is very important how to select in each iteration critical pairs from the list of all critical pairs $P$. This of course depends on the implemetation of the function \textit{Sel}. There are more possible implemetations:

\begin{itemize}
  \item The easiest implementation is to select all pairs from $P$. In this case we reduce all criticals pairs at the same time.
  \item If the function \textit{Sel} selects only one critical pair then the $F_4$ Algorithm is the Buchberger's Algorithm. In this case the \textit{Sel} function corresponds to the selection strategy in the Buchberger's Algorithm.
  \item The best function that Faug\`ere has tested is to select all critical pairs with a minimal total degree. Faug\`ere calls this strategy the \textit{normal strategy for} $F_4$.
\end{itemize}

\input{alg/Sel.tex}

\section{$F_5$ Algorithm}
