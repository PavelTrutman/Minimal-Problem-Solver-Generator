\chapter{Experiments}
To show the usefulness of our improvements of the automatic generator, we have compared several solvers of some minimal problems using different methods in the automatic generator. We have used the benchmark of the automatic generator to generate the solvers and to compare the results because this tool is designed to it perfectly.

We have divided the experiments into three parts. In each part, we are comparing easily comparable methods on which the speed up of the new implemented methods can be straightforwardly seen. In the first section, we are comparing one elimination solvers against multiple elimination solvers. In the second part, we are comparing solvers without the matrix partitioning used, with matrix partitioning used only to the last elimination and solvers with matrix partitioning used to all eliminations in the solver. In the last section, we are comparing solvers with different strategies of polynomial generation used. One solver is generated by the systematical generator and the second one is using the $F_4$ strategy.

To be able to compare the solvers, we have measured the time of computing the solutions for each set of parameters for each solver. In the tables below, we have picked up the maximal and minimal value and median of the times for each solver. We have also written the sizes of matrices to eliminate and approximate numbers of operations for each solver to the tables. By number of operations we mean number of operations which are needed by each solver to obtain the solutions from the set of parameters. To this number we count only operations required by the Gauss-Jordan eliminations for simplicity. To eliminate a matrix of dimensions $m \times n$, we need to do $(\max\{m, n\})^3$ operations which is the upper bound of the time complexity of the Gauss-Jordan elimination. To be able to compare the numerical stability of the solvers, we have substituted back each computed solution into the given equations and wrote down the results as errors. We have removed the errors equal to zero and compute the $\log_{10}$ of absolute values of errors. We have presented these values as histogram for each solver.

We have choosen the 9-point relative pose different radial distortion problem \cite{9pt} for the testing. This problem consists of four polynomial equations in four unknowns. The number of all parameters is 63. The definition of this minimal problem can be found under the name \texttt{ku9pt} in the folder \texttt{minimalProblems} in the automatic generator. To generate the solvers, we have used the default settings of the automatic generator obtained by calling of the function \textit{gbs\_InitConfig} if not specified differently. We have tested the generated solvers on randomly generated data, but the data remained the same within each experiment. Each solver was tried on $1\,000$ instances of parameters. All test were performed on Intel Xeon E5-2630 2.30 GHz based computer. The MATLAB R2014a 64-bit was used to the tests.

\section{Multiple elimination solver}
\label{exp:elim}
In this part, we are comparing one elimination solver with multiple elimination solvers. We have generated one solver according to the description in the section \ref{subsec:polynomialGenerator}. This first solver consist only of one elimination in the end. The second and the third solvers have been generated as explained in the section \ref{subsec:multipleSolver}. The second solver has been generated with the variable $step$ set to 1 therefore, an elimination is performed always when the maximal total degree of the generated polynomials is increased by 1. This second solver consist of four Gauss-Jordan eliminations. The third solver has been generated with the variable $step$ set to 2. This means, that an elimination is performed when the maximal total degree of the generated polynomials is increased by 2. This solver consists of two eliminations.

We have used the benchmark templates specified in the function \textit{bench\_elimination} from the folder \texttt{benchmark} in the automatic generator. All other settings have remained default.

The computing times, sizes of matrices to eliminate and numbers of operations required by these solvers are in the Table \ref{tab:elim}. The numerical stability of the solvers is shown in the Figure \ref{graph:elim} as histogram of $\log_{10}$ of absolute values of errors.

\begin{figure}[ht]
  \centering
  \resizebox{0.95\textwidth}{!}{\input{graphs/elim.tex}}
  \caption{Histogram of $\log_{10}$ of absolute values of errors for one elimination and multiple elimination solvers}
  \label{graph:elim}
\end{figure}

You can see that the numerical stability of the multiple elimination solvers is slightly worse than the numerical stability of the one elimination solver. In the contrary, the multi elimination solvers are approximately 1.5 times faster than the one elimination solver. Interesting is that the second and third solvers are equivalently fast, but one of them consists of four eliminations and the second one only of two eliminations. Therefore, we can not say that more eliminations lead to faster solvers. So, it is important to run the benchmark to find the optimal number of eliminations for each minimal problem and then choose the best solver for the application.

\section{Matrix partitioning}
\label{exp:part}
In this section, we compare the solvers using matrix partitioning as described in the section \ref{subsec:matrixPart}. For comparing, we have used multiple elimination solvers as described in the section \ref{subsec:multipleSolver}. We have set the variable $step$ to one so the generated solvers consist of four eliminations. The first solver has been generated without matrix partitioning. In the second one, matrix partitioning was used only for the last elimination and the third solver has been generated with matrix partitioning for all four eliminations used.

The benchmark templates used for this comparison are specified in the function \textit{bench\_\-mat\-rix\-Partitioning} from the folder \texttt{benchmark} in the automatic generator. The variable $step$ was set to 1 and all other settings have remained default.

The computing times, sizes of matrices to eliminate and numbers of operations required by these tree solvers are in the Table \ref{tab:part} and the numerical stability is shown as histogram of $\log_{10}$ of absolute values of errors in the Figure \ref{graph:part}.

\begin{figure}[ht]
  \centering
  \resizebox{0.95\textwidth}{!}{\input{graphs/part.tex}}
  \caption{Histogram of $\log_{10}$ of absolute values of errors for solver without matrix partitioning, solver with matrix partitioning only for the last elimination used and solver with matrix partitioning for all eliminations used}
  \label{graph:part}
\end{figure}

We can see that the numerical stability remained the same for all three solvers. The solver with matrix partitioning for the last elimination used is approximately twice faster than solver without matrix paritioning. There is no big difference between the solver with matrix partitioning for the last elimination used and the solver with matrix partitioning used for all eliminations in the solver. The reason is, that when eliminating not the last matrix in the solver, we have to eliminate all the coupling columns. We do not have to do this when it is the last elimination. Therefore, the speed up of elimination of not the last matrix is not so big as the speed up of the last elimination.

\section{$F_4$ strategy}
\label{exp:gen}
At last, we have compared the solver generated by the systematical polynomial generator with solver generated with the $F_4$ strategy used. The first solver has been generated according to the decription in the section \ref{subsec:polynomialGenerator} using the systematical polynomial generator. The second one uses the $F_4$ strategy described in the section \ref{subsec:F4}.

We have used the benchmark templates that are defined in the function \textit{bench\_poly\-nomialGenerator} which is stored in the folder \texttt{benchmark} in the automatic generator. All other settings have remained default.

The numerical stability of both solvers are shown in the Figure \ref{graph:gen} as histogram of $\log_{10}$ of absolute values of errors. The computing times, sizes of matrices to eliminate and numbers of operations required by these solvers are in the Table \ref{tab:gen}.

\begin{figure}[ht]
  \centering
  \resizebox{0.95\textwidth}{!}{\input{graphs/gen.tex}}
  \caption{Histogram of $\log_{10}$ of absolute values of errors for solver generated by the systematical generator and for solver using the $F_4$ strategy}
  \label{graph:gen}
\end{figure}

From the results, we can see that the numerical stability has remained the same for both solvers. The solver which uses the $F_4$ strategy is about 4 times faster than the solver generated by the systematical polynomial generator.

\begin{landscape}
\begin{table}[ht]
  \centering
  \begin{tabular}{|c||ccc|}
    \hline
      & \textbf{One elimination} & \textbf{Multiple elimination} & \textbf{Multiple elimination} \\
      & \textbf{solver}          & \textbf{solver} ($step = 1$)  & \textbf{solver} ($step = 2$)\\
    \hline\hline
    \input{sources/graphs/elim_time.tex}
    \multirow{2}{*}{\textbf{sizes of matrices}} & \multirow{2}{*}{$185 \times 209$} & $64 \times 104; 80 \times 119$ & $133 \times 181$\\
                                                &                                   & $95 \times 125; 49 \times 73$  & $81 \times 105$\\
    \textbf{number of operations} & $9\;129\;329$ & $5\;152\;165$ & $7\;087\;366$\\
    \hline
  \end{tabular}
  \caption{Computing times of one and multiple elimination solvers}
  \label{tab:elim}
\end{table}

\begin{table}[!ht]
  \centering
  \begin{tabular}{|c||ccc|}
    \hline
      & \textbf{Without matrix} & \textbf{Matrix partitioning}      & \textbf{Matrix paritioning} \\
      & \textbf{partitioning}   & \textbf{for the last elimination} & \textbf{for all eliminations} \\
    \hline\hline
    \input{sources/graphs/part_time.tex}
     \textbf{$1^{\text{st}}$ matrix} & $64 \times 104$ & $64 \times 104$                                      & $30 \times 47; 34 \times 44; 14 \times 35; 50\times 35$\\
     \textbf{$2^{\text{nd}}$ matrix} & $80 \times 119$ & $80 \times 119$                                      & $41 \times 48; 39 \times 49; 5 \times 29; 75 \times 29$\\
     \textbf{$3^{\text{rd}}$ matrix} & $95 \times 125$ & $95 \times 125$                                      & $50 \times 24; 45 \times 46; 32 \times 56; 63 \times 56$\\
     \textbf{$4^{\text{th}}$ matrix} & $49 \times 73$  & $29 \times 18;20 \times 15; 16 \times 40; 0\times 0$ & $29 \times 18;20 \times 15; 16 \times 40; 0\times 0$\\
     \textbf{number of operations} & $5\;152\;165$ & $4\;859\;537$ & $1\;775\;775$\\
    \hline
  \end{tabular}
  \caption{Computing times of solver without matrix partitioning, of solver with matrix partitioning for the last elimination used and of solver with matrix partitioning for all eliminations used}
  \label{tab:part}
\end{table}
\end{landscape}

~\vfill
\begin{table}[ht]
  \centering
  \begin{tabular}{|c||cc|}
    \hline
    & \textbf{Systematical}    & \textbf{$F_4$ strategy} \\
    &  \textbf{generator used} & \textbf{used} \\
    \hline\hline
    \input{sources/graphs/gen_time.tex}
    \multirow{6}{*}{\textbf{sizes of matrices}} & \multirow{6}{*}{$185 \times 209$} & $2 \times 12; 13 \times 30$\\
     & & $22\times46; 0\times 0$\\
     & & $52\times85; 36\times 65$\\
     & & $37\times62; 68\times 92$\\
     & & $44\times68; 0\times 0$\\
     & & $0\times0; 15\times 39$\\
     \textbf{number of operations} & $9\;129\;329$ & $2\;405\;581$\\
    \hline
  \end{tabular}
  \caption{Computing times of solver generated by the systematical generator and of the solver using the $F_4$ strategy}
  \label{tab:gen}
\end{table}
\vfill
